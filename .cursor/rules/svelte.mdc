---
description: When writing code for svelte (.svelte or .svelte.ts files) make sure to do the following.
globs: **/*.svelte,**/*.svelte.ts,*.svelte,*.svelte.ts,*.remote.ts,**/*.remote.ts
alwaysApply: false
---

- always use typescript, the script should be <script lang="ts">
- use svelte 5 (runes, snippets, etc.) syntax
- use remote functions where you can, they are the preferred way to fetch data from the server
- use the new async svelte features when it makes sense to with `<svelte:boundary>` and `await`. it's very similar to how suspense works in react

# svelte 5 docs:

**Core Principles & Setup:**

- **Svelte 5 Mandate:** `MUST` use Svelte 5 API (Runes). Unchanged syntax (`{#if}`) reused from S4 knowledge.
- **Runes Overview:** Built-in keywords (`$`) controlling compiler. `CORRECT: Use as language keywords. AVOID: Importing/calling runes like functions.` Valid in `.svelte`, `.svelte.js`, `.svelte.ts` files.
- **`.svelte` Files:** Optional `<script>`, `<script module>`, `<style>`, markup sections.
  - `<script>`: Runs per component instance. Use runes here.
  - `<script module>`: Runs once per module load. Can export non-default bindings. Variables accessible in instance script, not vice-versa.
  - `<style>`: CSS scoped to the component by default.
- **`.svelte.js`/`.svelte.ts` Files:** Regular JS/TS modules supporting runes for reactive logic/state sharing.
  ```js
  // store.svelte.js
  export let count = $state(0); // Export reactive state
  export const increment = () => count++;
  ```
- **DOM Event Syntax:** `USE onclick={...} (Replaces S4 on:click={...}).` No colon.

**State Management (`$state`)**

- **`$state`:** Creates reactive state. `USE let count = $state(0); (Replaces S4 let count = 0; for reactivity).`

  ```svelte
  <script>
  	let count = $state(0);
  </script>

  <button onclick={() => count++}>Clicked: {count}</button>
  ```

- **Deep State:** Objects/arrays become deeply reactive proxies. Modifications trigger updates.
  ```js
  let obj = $state({ nested: { value: 1 } });
  obj.nested.value = 2; // UI updates
  let arr = $state([]);
  arr.push({ text: 'new' }); // UI updates, new item is reactive
  ```
  `CORRECT: Access properties directly: obj.nested.value. AVOID: Destructuring reactive proxies: let { value } = obj.nested; (breaks reactivity).`
- **Direct Updates:** `CORRECT: Update $state variables directly: count++, arr.push({...}), obj.prop = value. AVOID: Wrapping state in unnecessary custom objects/stores for simple component state.`
- **Classes:** Use `$state` in class fields. Handle `this` context for methods (use arrow functions or `() => instance.method()` in handlers).
  ```js
  class Todo {
  	done = $state(false);
  	text = $state('');
  	reset = () => {
  		/*...*/
  	};
  }
  ```
- **Exporting State:** `CORRECT: Export stateful object: export const counter = $state({ count: 0 }); OR Export getters/actions: export function getCount() { return count; } export function increment() { count++; }. AVOID: Directly exporting reassigned state: export let count = $state(0);.`
- **`$state.raw`:** Shallow, non-tracked state. Updates require reassignment.
  ```js
  let person = $state.raw({ name: 'Zeno' });
  person = { ...person, age: 71 }; // Correct update
  ```
  `CORRECT: Reassign entire object. AVOID: Mutating properties of raw state.`
- **`$state.snapshot`:** Creates a non-reactive, plain object copy. `CORRECT: Use ONLY if external API needs plain object. AVOID: Overusing.`
- **Passing State:** Pass by value semantics. `CORRECT: Pass state to functions via getters: fn(() => stateVal). AVOID: Passing raw state variables assuming live updates inside function.`

**Derived State (`$derived`)**

- **`$derived`:** Computes reactive values from dependencies. `USE const doubled = $derived(count * 2); (Replaces S4 $: double = count * 2;).`

  ```svelte
  <script>
  	let count = $state(0);
  	const doubled = $derived(count * 2);
  </script>

  <p>{count} * 2 = {doubled}</p>
  ```

- **`$derived.by`:** For multi-line/complex logic. `USE $derived.by(() => {...}) when passing a function.`
  ```js
  const total = $derived.by(() => {
  	let sum = 0;
  	/*...*/ return sum;
  });
  ```
- **Reactivity:** Values are not deep proxies. Updates trigger when dependencies change value. Uses push-pull reactivity (recalculated on read).
- **Purity:** `CORRECT: Keep $derived pure (no side effects). AVOID: Assignments/API calls inside $derived.`
- **Dependencies:** Tracks synchronous reads. Use `untrack()` to exclude.
- **Overriding:** Temporarily assign new value (optimistic UI). Reverts on next dependency update. `CORRECT: Assign directly: likes = 1;. AVOID: Overriding via $effect.`
  ```svelte
  <script>
  	let likes = $derived(post.likes);
  	async function like() {
  		likes++; /*...*/
  	}
  </script>
  ```

**Side Effects (`$effect`)**

- **`$effect`:** Runs code reactively _after_ DOM updates when dependencies change. Browser-only. `USE $effect(() => {...}); (Replaces S4 $: console.log(...) for side effects).`
  ```svelte
  <script>
  	let size = $state(50);
  	$effect(() => {
  		console.log('Size:', size);
  	});
  </script>
  ```
- **Usage:** `CORRECT: Use $effect for: logging, non-declarative DOM manipulation, external subscriptions (WebSocket, timers), analytics. AVOID: Using $effect for state sync/derivation (use $derived).`
- **Lifecycle & Cleanup:** Can return a cleanup function (runs before re-run or on unmount). `CORRECT: Return cleanup for intervals, listeners, etc. AVOID: Forgetting cleanup.`
  ```js
  $effect(() => { const id = setInterval(...); return () => clearInterval(id); });
  ```
- **Dependencies:** Tracks synchronous reads only. Async values (post-`await`, `setTimeout`) not tracked.
- **`$effect.pre`:** Runs _before_ DOM updates. `CORRECT: Use for pre-DOM tasks (reading scroll position). AVOID: Standard post-update effects.`
- **`$effect.tracking`:** Debugging helper: returns `true` if inside reactive context.
- **`$effect.root`:** Creates non-tracked scope needing manual cleanup via returned function. Niche use case.

**Component Inputs (`$props`)**

- **`$props`:** Access component inputs. `USE let { foo = true, bar } = $props(); (Replaces S4 export let foo = true; export let bar;).`

  ```svelte
  <!-- MyComponent.svelte -->
  <script>
  	let { adjective = 'great' }: { adjective?: string } = $props();
  </script>

  <p>Component is {adjective}</p>
  ```

- **Immutability:** `CORRECT: Treat props read-only. Use callbacks or $bindable for changes. AVOID: Directly modifying props: adjective = 'new';.` Reassigning props locally is allowed but usually discouraged; mutation has complex rules/warnings (see source doc if needed).
- **Features:** Fallbacks (`prop = 'default'`), renaming (`{ class: className }`), rest (`{ a, ...rest }`).
- **`$props.id()`:** Generates unique component instance ID string. `CORRECT: Use for unique IDs (labels, aria). AVOID: Manual ID generation.`
- **Typing:** Use interfaces or inline types: `let { name }: { name: string } = $props();`. For generics: `<script lang="ts" generics="T"> ... let { item }: { item: T } = $props(); </script>`.

**Two-Way Binding (`$bindable`)**

- **`$bindable`:** Explicitly marks prop for two-way binding (`bind:prop`). `USE let { value = $bindable('fallback') } = $props(); (Unlike S4 implicit bindable props).`

  ```svelte
  <!-- FancyInput.svelte -->
  <script>
  	let { value = $bindable('') } = $props();
  </script>

  <input bind:value />
  ```

  ```svelte
  <!-- App.svelte -->
  <script>
  	let name = $state('world');
  </script>

  <FancyInput bind:value={name} />
  ```

  `CORRECT: Use when two-way binding is needed. AVOID: Overusing; prefer one-way flow + callbacks.`

**Snippets (Reusable Markup Chunks)**

- **Concept:** Define reusable, parameterized **HTML markup** sections within the component **template area**. `USE {#snippet ...}` (Replaces S4 `<slot>`).
- **Definition:** `{#snippet name(params)}...{/snippet}`. Parameters are optional, support defaults (`p='default'`), and destructuring. No rest params (`...args`).

  ```svelte
  <script>
  	let message = 'Hello'; // Accessible by snippet below
  </script>

  <!-- Snippet defined in template markup -->
  {#snippet greet(name = 'world')}
  	<p>{message} {name}!</p>
  {/snippet}
  ```

- **Rendering:** Use `{@render snippetName(args)}` **in the template** to display a snippet. `USE {@render ...}` (Replaces S4 `<slot ...>`).
  - `CORRECT: Always invoke with parentheses: {@render greet()}, {@render greet('Svelte')}. AVOID: Omitting (): {@render greet}.`
  - Render optional snippets: `{@render maybeSnippet?.()}`.
  ```svelte
  <!-- Rendering in template -->
  {@render greet('Developer')}
  ```
- **Scope:** Snippets access variables from their outer `<script>` or template scope. Render within scope or pass down.
- **Passing Snippets (in template):**
  - **As Props:** Pass like values: `<ChildComponent {greet} />`.
  - **Implicit Props:** Define inside component tag: `<Child>{#snippet greet ...}{/snippet}</Child>`. Becomes `greet` prop on `Child`.
  - **`children` Snippet:** Direct content `<Child>Text</Child>` becomes `children` prop. Render via `{@render children()}` in `Child`.

**Template Syntax**

- **Basic Markup:** Lowercase tags = HTML, Capitalized = Components. Attributes: Standard HTML, JS expressions `{value}`, boolean shorthand `{disabled}`, spread `{...attrs}`. Props: Similar syntax, shorthand `{prop}`, spread `{...props}`.
- **Text Expressions:** `{expression}`. Escaped by default. `{@html rawHtmlString}` for unescaped HTML (use with caution!).
- **Comments:** `<!-- HTML comment -->`. `<!-- svelte-ignore directive -->`. `<!-- @component Doc comment -->`.
- **Logic Blocks:**
  - `{#if condition}...{:else if condition}...{:else}...{/if}`
  - `{#each items as item, index (item.id)}...{:else}...{/each}` (Key `(item.id)` is crucial for performance/animation). Supports destructuring.
  - `{#await promise}...{:then value}...{:catch error}...{/await}` (Blocks optional).
  - `{#key expression}...{/key}` (Destroys/recreates content when expression changes).
- **`{@const ...}`:** Define local constant: `{@const area = width * height}`. Allowed inside blocks/components.
- **`{@debug ...}`:** Debug helper: `{@debug var1, var2}` logs changes, pauses debugger. Dev-only.

**Debugging Reactivity (`$inspect`) (Development Only)**

- **Purpose:** Observe state changes and trace dependencies during development. **`$inspect` is removed in production builds (no-op).**
- **Log State Changes:** `$inspect(var1, var2, ...)` logs values when they change and pauses the debugger if devtools are open.

  ```svelte
  <script>
  	let count = $state(0);
  	$inspect(count);
  </script>

  <button onclick={() => count++}>Inc: {count}</button>
  ```

- **Custom Inspection (`.with(callback)`):** Execute custom logic on change. `callback(type, value)` where `type` is 'init' or 'update'.
  ```js
  // Trigger debugger when count updates and exceeds 5
  $inspect(count).with((type, val) => {
  	if (type === 'update' && val > 5) debugger;
  });
  ```
- **Trace Dependencies (`.trace()`):** Inside `$effect` or `$derived`, use `$inspect.trace('optional label')` to log which specific dependencies triggered the re-run.
  ```js
  $effect(() => {
  	$inspect.trace(); // Logs which dependency change triggered this effect
  	console.log('Effect ran:', someState);
  });
  ```

**Data Binding (`bind:`)**

- **Concept:** Two-way data binding. `bind:prop={value}` or shorthand `bind:value`.
- **Common Inputs:** `bind:value` (text, number, range, select), `bind:checked` (checkbox), `bind:group` (radio/checkbox group), `bind:files` (file input). Use `defaultValue`/`defaultChecked` for form reset behavior.
- **Media Elements:** `bind:currentTime`, `bind:paused`, `bind:duration` (audio/video), `bind:videoWidth/Height` (video), `bind:naturalWidth/Height` (img).
- **Other Elements:** `bind:open` (details), `bind:innerHTML`/`textContent` (contenteditable), `bind:offsetWidth`/`Height`, `clientWidth`/`Height`, `scrollWidth`/`Height`, `scrollLeft`/`Top` (readonly dimensions/scroll).
- **`bind:this`:** Get reference to DOM element or component instance.
- **Component Binding:** Requires child prop marked with `$bindable`. `<Child bind:value={parentState} />`.
- **Function Bindings:** Advanced control: `bind:value={() => getter, (v) => setter(v)}`. Readonly binding: `bind:clientWidth={null, redrawFn}`.

**Actions (`use:`)**

- **`use:action={params}`:** Attach JS behavior to an element lifecycle.

  ```svelte
  <script>
  	import { tick } from 'svelte'; // Use tick if needed inside action
  	/** @type {import('svelte/action').Action<HTMLDivElement, { speed: number }>} */
  	function longpress(node, params = { speed: 100 }) {
  		// setup logic, e.g., event listeners
  		console.log('Action mounted with speed', params.speed);
  		return {
  			// update(newParams) { /* logic if params change */ }, // Optional update function
  			destroy() {
  				/* cleanup logic */
  			}
  		};
  	}
  </script>

  <div use:longpress={{ speed: 50 }}>Long press me</div>
  ```

- **Runs:** Only in browser, once on mount. `update` runs if params change. `destroy` runs on unmount.

**Transitions & Animations**

- **`transition:fn={params}`:** Animate element in/out of DOM (bidirectional). From `svelte/transition`. Use `|global` modifier for non-local transitions.
- **`in:fn={params}` / `out:fn={params}`:** Unidirectional transitions.
- **`animate:fn={params}`:** Animate reordering within keyed `{#each}` blocks. From `svelte/animate`.
- **Custom Functions:** Return object with `delay`, `duration`, `easing`, and `css` (preferred) or `tick`.

**Styling**

- **`<style>` Block Usage:** Define component styles within a `<style>` tag. **The content inside `<style>` MUST be standard CSS syntax; it's processed at compile time, not generated dynamically with JS `{expressions}`.**

  ```svelte
  <script>
  	// Svelte variable holding a color value
  	let mainColor = $state('blue');
  </script>

  <!-- Set the CSS variable using the Svelte variable -->
  <p style:--p-color={mainColor}>Styled text</p>

  <style>
  	/* Standard CSS using the variable */
  	p {
  		color: var(--p-color, black); /* Use CSS variable with fallback */
  		font-weight: bold;
  	}
  </style>
  ```

- **Scoped Styles:** By default, CSS in `<style>` is **scoped** to the component (Svelte adds unique classes). Specificity is boosted. `@keyframes` also scoped.
- **Global Styles:** `CORRECT: Use :global(.selector) or :global { ... } block. AVOID: Overusing.` Use `-global-` prefix for global `@keyframes`.
- **Inline Styles (`style:`):** Set styles directly: `style:opacity={value}`, shorthand `style:color`, important `style:color|important="blue"`. Also used to set CSS custom properties (`style:--my-var={jsValue}`).
- **CSS Classes (`class` / `class:`):**
  - **`class` Attribute (Recommended):** `class="string"`, `class={expr}`, object `class={{ active: isActive }}`, array `class={[isActive && 'active']}`.
  - `class:` Directive (Legacy): `class:name={bool}` or `class:name`. Prefer `class` attribute.
- **CSS Custom Properties (`--*`):** Pass to components: `<Comp --bg-color="blue" />`. Access in CSS: `var(--bg-color, fallbackValue)`. Set dynamically using `style:--my-var={jsValue}`.

**Special Elements `<svelte:...>`**

- **`<svelte:head>`:** Insert content into `document.head`.
- **`<svelte:element this={tag} {...attrs}>`:** Render dynamic HTML element type. `bind:this` only.
- **`<svelte:window bind:scrollY={y} on:event={handler}/>`:** Interact with `window`.
- **`<svelte:document on:event={handler} use:action />`:** Interact with `document`.
- **`<svelte:body on:event={handler} use:action />`:** Interact with `document.body`.
- **`<svelte:boundary onerror={handler}>{#snippet failed(e,r)}</svelte:boundary>`:** Catch rendering errors. Provide `failed` snippet for fallback UI. `onerror` prop for programmatic handling. Catches render/effect errors, not async/event handler errors.

**Runtime API**

- **Stores (`svelte/store`):** For complex async/external state. `writable`, `readable`, `derived`, `readonly`, `get`. Access value via `$store` prefix in components. Prefer runes (`.svelte.js` state) for simpler cases.
- **Context API (`svelte`):** Pass values down component tree without props. `setContext(key, value)`, `getContext(key)`, `hasContext(key)`. Useful for theme, user data.
- **Lifecycle (`svelte`):** `onMount(() => cleanup?)` (browser-only, runs after mount), `onDestroy(() => ...)` (runs before unmount), `tick()` (promise resolving after updates). `$effect.pre`/`$effect` replace `before/afterUpdate`.
- **Imperative API (`svelte`):** Less common for generation. `mount(Comp, { target, props })`, `unmount(instance)`, `hydrate(Comp, { target, props })`. SSR: `render(Comp, { props })` from `svelte/server`.

**Stores with Classes and Context**

- **Class-based Stores:** Create reactive stores using classes with `$state` and `$derived` runes. `CORRECT: Use classes for complex state management with methods and derived values. AVOID: Overusing for simple component state.`
  ```ts
  class AuthStore {
    private userId = $state<string | null>(null);
    
    isLoading = $derived(this.userId === null);
    isAuthenticated = $derived(this.userId !== null);
    
    setUser = (id: string) => {
      this.userId = id;
    };
  }
  ```
- **Context Pattern:** Use `createContext` with `setContext`/`getContext` to share store instances across component tree.
  ```ts
  import { createContext } from 'svelte';
  
  const [getStore, setStore] = createContext<AuthStore>();
  
  // In parent component
  setStore(new AuthStore());
  
  // In child components
  const store = getStore();
  ```
- **Setup Pattern:** `CORRECT: Create context tuple, initialize store in parent component with setContext, access in children with getContext. AVOID: Storing context keys in separate constants (unnecessary abstraction).`
  ```ts
  const [internalGetStore, internalSetStore] = createContext<AuthStore>();
  
  export const getStore = () => {
    const store = internalGetStore();
    if (!store) throw new Error('Store not found');
    return store;
  };
  
  export const setStore = () => internalSetStore(new AuthStore());
  ```
- **Usage:** Parent components call `setStore()` to initialize; child components call `getStore()` to access the shared instance. All `$state` and `$derived` properties remain reactive.

---

# sveltekit docs:

**Core Concepts**

- **Framework:** Builds full-stack apps with Svelte components. Handles routing, data loading, build optimization, SSR/CSR/SSG.
- **Project Structure:** Key items: `src/routes` (app pages/endpoints), `src/lib` (shared code, `$lib` alias), `src/app.html` (HTML shell), `static` (public assets), `svelte.config.js`, `vite.config.js`.

**Routing (Filesystem-based in `src/routes`)**

- **Pages:** `+page.svelte`. `USE +page.svelte (Replaces S4 route.svelte).`
- **Layouts:** `+layout.svelte`. Wrap pages/child layouts. Use `{@render children()}`. Nesting inherits.
- **Data Loading:** `+page.js`/`+layout.js` (universal load), `+page.server.js`/`+layout.server.js` (server-only load & actions).
- **API Endpoints:** `+server.js`. Export functions named `GET`, `POST`, etc.
- **Remote Functions:** `.remote.ts`. For example, for a set of remote functions for "todos" the file name would be `todos.remote.ts`.
- **Error Pages:** `+error.svelte`. Catches errors in its subtree.
- **Dynamic Routes:** `[param]`, rest `[...param]`, optional `[[param]]`. Matchers `[param=matcher]` (defined in `src/params/matcher.js`).

**Page Options (Export `const` from `+page/layout .js/.server.js`)**

- **`prerender = true`:** Static Site Generation (SSG). Needs `adapter-static`. Dynamic routes need `entries()`.
- **`ssr = false`:** Client-Side Rendering only (SPA mode).
- **`csr = false`:** No JS hydration (static HTML).
- **`trailingSlash = 'always' | 'never' | 'ignore'`:** URL format.

**Other Core Features**

- **Hooks (`hooks.server.js`, `hooks.client.js`):** `handle` (middleware, modify `event.locals`), `handleError` (catch unexpected errors), `handleFetch` (intercept server fetch).
- **Server-only Modules:** Use `$lib/server/`, `*.server.js`, `$env/.../private`. Build fails if imported into client code.
- **State Management:** `CORRECT: Pass server data via load/props. Use context/stores/URL for client state. AVOID: Shared mutable server variables.`
- **Error Handling:** `error(status, data)` helper throws expected error -> `+error.svelte`. Unexpected errors -> `handleError`.
- **Link Options (`<a>` attributes):** `data-sveltekit-preload-data/code`, `data-sveltekit-reload`, etc. Tune navigation/preloading.
- **Service Workers (`src/service-worker.js`):** Offline support via `$service-worker` module.
- **Snapshots (`snapshot` export):** Preserve ephemeral component state across navigation.
- **Shallow Routing (`$app/navigation`):** `pushState`/`replaceState` to change URL/state without navigation. Access via `page.state`.

**Best Practices**

- **SEO:** Use `<svelte:head>` for metadata (`title`, `description`). Create `sitemap.xml` endpoint. Keep SSR enabled for public pages.

**Key Modules Reference**

- **`@sveltejs/kit`:** `error`, `fail`, `redirect`, `json`, `text`.
- **`$app/forms`:** `enhance`, `applyAction`, `deserialize`.
- **`$app/navigation`:** `goto`, `invalidate`, `invalidateAll`, `preloadData`, `preloadCode`, `beforeNavigate`, `afterNavigate`, `pushState`, `replaceState`.
- **`$app/paths`:** `base`, `assets`.
- **`$app/server` (Server-only):** `read`, `getRequestEvent`.
- **`$app/state`:** `page`, `navigating`, `updated`.
- **`$env/...`:** Access environment variables.
- **`$lib`:** Alias for `src/lib`.

**Import Requirements**

Understanding what needs an `import` statement is crucial.

**1. DO NOT Import (Globally Available or Implicit):**

- **Runes:** All runes (`$state`, `$derived`, `$effect`, `$props`, `$bindable`, `$inspect`, `$host`) are compiler keywords. **Never** import them.
- **Template Blocks/Directives:** All template syntax (`{#if}`, `{#each}`, `{#await}`, `{#snippet}`, `{@render}`, `{@html}`, `{@debug}`, `{@const}`, `bind:`, `use:`, `transition:`, `in:`, `out:`, `animate:`, `style:`, `class:`) are part of the Svelte template language. **No import needed.**
- **Special Elements:** All `<svelte:...>` elements (`<svelte:head>`, `<svelte:window>`, `<svelte:document>`, `<svelte:body>`, `<svelte:element>`, `<svelte:options>`, `<svelte:boundary>`) are part of the Svelte language. **No import needed.**

**2. Imports Required When Needed:**

- **From `svelte`:**
  - Lifecycle functions: `onMount`, `onDestroy`, `tick`.
  - Context API: `setContext`, `getContext`, `hasContext`, `getAllContexts`.
  - Imperative API: `mount`, `unmount`, `hydrate`.
- **From `svelte/transition`, `svelte/animate` and `svelte/easing`:**
  - Built-in transitions, animations and easing functions
- **From `@sveltejs/kit`:**
  - API/Action helpers: `error`, `fail`, `redirect`, `json`, `text`.
- **From `$app/...` Modules (SvelteKit):**
  - `$app/forms`: `enhance`, `applyAction`, `deserialize`.
  - `$app/navigation`: `goto`, `invalidate`, `invalidateAll`, `beforeNavigate`, `afterNavigate`, `preloadData`, `preloadCode`, `pushState`, `replaceState`, etc.
  - `$app/paths`: `base`, `assets`.
  - `$app/server` (Server-only): `read`, `getRequestEvent`.
  - `$app/state`: `page`, `navigating`, `updated`.
  - `$app/environment`: `dev`, `browser`, `building`.
- **From `$env/...` Modules (SvelteKit):**
  - Environment variables (`$env/static/public`, `$env/static/private`, etc.).

# remote functions docs:

Concise Cheat Sheet (query, query.batch, form, command, prerender)

Setup (opt-in)

```js
// svelte.config.js
/** @type {import('@sveltejs/kit').Config} */
const config = {
	kit: { experimental: { remoteFunctions: true } },
	compilerOptions: { experimental: { async: true } }
};
export default config;
```

Overview

- Define in `.remote.ts` under `src/`
- Client calls are transformed to fetch the server implementation
- `await` in components + `<svelte:boundary>` recommended for loading/error UI

query

The `query` function allows you to read dynamic data from the server (for _static_ data, consider using [`prerender`](#prerender) instead):

```js
/// file: src/routes/blog/data.remote.js
// @filename: ambient.d.ts
declare module '$lib/server/database' {
	export function sql(strings: TemplateStringsArray, ...values: any[]): Promise<any[]>;
}
// @filename: index.js
// ---cut---
import { query } from '$app/server';
import * as db from '$lib/server/database';

export const getPosts = query(async () => {
	const posts = await db.sql`
		SELECT title, slug
		FROM post
		ORDER BY published_at
		DESC
	`;

	return posts;
});
```

> [!NOTE] Throughout this page, you'll see imports from fictional modules like `$lib/server/database` and `$lib/server/auth`. These are purely for illustrative purposes — you can use whatever database client and auth setup you like.
>
> The `db.sql` function above is a [tagged template function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates) that escapes any interpolated values.

The query returned from `getPosts` works as a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves to `posts`:

```svelte
<!--- file: src/routes/blog/+page.svelte --->
<script>
	import { getPosts } from './data.remote';
</script>

<h1>Recent posts</h1>

<ul>
	{#each await getPosts() as { title, slug }}
		<li><a href="/blog/{slug}">{title}</a></li>
	{/each}
</ul>
```

Until the promise resolves — and if it errors — the nearest [`<svelte:boundary>`](../svelte/svelte-boundary) will be invoked.

While using `await` is recommended, as an alternative the query also has `loading`, `error` and `current` properties:

```svelte
<!--- file: src/routes/blog/+page.svelte --->
<script>
	import { getPosts } from './data.remote';

	const query = getPosts();
</script>

<h1>Recent posts</h1>

{#if query.error}
	<p>oops!</p>
{:else if query.loading}
	<p>loading...</p>
{:else}
	<ul>
		{#each query.current as { title, slug }}
			<li><a href="/blog/{slug}">{title}</a></li>
		{/each}
	</ul>
{/if}
```

> [!NOTE] For the rest of this document, we'll use the `await` form.

### Query arguments

Query functions can accept an argument, such as the `slug` of an individual post:

```svelte
<!--- file: src/routes/blog/[slug]/+page.svelte --->
<script>
	import { getPost } from '../data.remote';

	let { params } = $props();

	const post = $derived(await getPost(params.slug));
</script>

<h1>{post.title}</h1><div>{@html post.content}</div>
```

Since `getPost` exposes an HTTP endpoint, it's important to validate this argument to be sure that it's the correct type. For this, we can use any [Standard Schema](https://standardschema.dev/) validation library such as [Zod](https://zod.dev/) or [Valibot](https://valibot.dev/):

```js
/// file: src/routes/blog/data.remote.js
// @filename: ambient.d.ts
declare module '$lib/server/database' {
	export function sql(strings: TemplateStringsArray, ...values: any[]): Promise<any[]>;
}
// @filename: index.js
// ---cut---
import * as v from 'valibot';
import { error } from '@sveltejs/kit';
import { query } from '$app/server';
import * as db from '$lib/server/database';

export const getPosts = query(async () => { /* ... */ });

export const getPost = query(v.string(), async (slug) => {
	const [post] = await db.sql`
		SELECT * FROM post
		WHERE slug = ${slug}
	`;

	if (!post) error(404, 'Not found');
	return post;
});
```

Both the argument and the return value are serialized with [devalue](https://github.com/sveltejs/devalue), which handles types like `Date` and `Map` (and custom types defined in your [transport hook](hooks#Universal-hooks-transport)) in addition to JSON.

### Refreshing queries

Any query can be re-fetched via its `refresh` method, which retrieves the latest value from the server:

```svelte
<button onclick={() => getPosts().refresh()}> Check for new posts </button>
```

> [!NOTE] Queries are cached while they're on the page, meaning `getPosts() === getPosts()`. This means you don't need a reference like `const posts = getPosts()` in order to update the query.

## query.batch

`query.batch` works like `query` except that it batches requests that happen within the same macrotask. This solves the so-called n+1 problem: rather than each query resulting in a separate database call (for example), simultaneous queries are grouped together.

On the server, the callback receives an array of the arguments the function was called with. It must return a function of the form `(input: Input, index: number) => Output`. SvelteKit will then call this with each of the input arguments to resolve the individual calls with their results.

```js
/// file: weather.remote.js
// @filename: ambient.d.ts
declare module '$lib/server/database' {
	export function sql(strings: TemplateStringsArray, ...values: any[]): Promise<any[]>;
}
// @filename: index.js
// ---cut---
import * as v from 'valibot';
import { query } from '$app/server';
import * as db from '$lib/server/database';

export const getWeather = query.batch(v.string(), async (cities) => {
	const weather = await db.sql`
		SELECT * FROM weather
		WHERE city = ANY(${cities})
	`;
	const lookup = new Map(weather.map(w => [w.city, w]));

	return (city) => lookup.get(city);
});
```

```svelte
<!--- file: Weather.svelte --->
<script>
	import CityWeather from './CityWeather.svelte';
	import { getWeather } from './weather.remote.js';

	let { cities } = $props();
	let limit = $state(5);
</script>

<h2>Weather</h2>

{#each cities.slice(0, limit) as city}
	<h3>{city.name}</h3>
	<CityWeather weather={await getWeather(city.id)} />
{/each}

{#if cities.length > limit}
	<button onclick={() => (limit += 5)}> Load more </button>
{/if}
```

form

```ts
import { form } from '$app/server';

export const createPost = form(schema, async (data, invalid) => {
	// mutate, may call invalid(...) for field/global errors
	// redirect(...) or return data (available as createPost.result)
});

// <form {...createPost}> ... </form>
```

- Spreads onto `<form>`; progressive enhancement by default
- `fields.*.as(type[, value])`, `fields.*.issues()`, `fields.value()`, `fields.set(...)`
- `validate(opts?)`, `preflight(schema)` for client‑side validation
- `pending`, `result`, `buttonProps`, `enhance(cb)`, `for(id)`
- Single‑flight updates:
  - Server: call `someQuery(args).refresh()` or `.set(value)` inside handler
  - Client: `await submit().updates(someQuery(args)[.withOverride(...)])`

command

```ts
import { command } from '$app/server';

export const addLike = command(v.string(), async (id) => {
	// mutate
});

// call from handlers (not during render)
```

- Not tied to elements; cannot be called during render
- No redirects (return shape and handle on client if needed)
- Must specify affected queries:
  - Server: `someQuery(args).refresh()` / `.set(...)`
  - Client: `await addLike(id).updates(someQuery(id)[.withOverride(...)])`

prerender

```ts
import { prerender } from '$app/server';

export const getStatic = prerender(async () => ({
	/* data */
}));
// prerender(v.string(), async (arg) => { ... }, { inputs: () => [...], dynamic: false|true })
```

- Runs at build; cacheable; ideal for rarely changing data
- `inputs()` seeds build‑time calls; `dynamic:true` keeps server impl for runtime arguments
- Note: when entire page `prerender = true`, you can't use dynamic `query`

Validation & Errors

- Pass Standard Schema (e.g., Zod/Valibot) as first arg for `query`, `form`, `command`, `prerender`
- Use `'unchecked'` to opt out (be careful)
- Customize 400s via `handleValidationError` hook

Request context

- `getRequestEvent()` available inside handlers for cookies, etc.
- Caveats: cannot set headers (except cookies inside `form`/`command`); `route/params/url` refer to the calling page, not the generated endpoint; don't use them for auth decisions

Redirects

- Allowed in `query`, `form`, `prerender`
- Not allowed in `command` (return data and handle client‑side)

# async svelte docs:

As of Svelte 5.36, you can use the `await` keyword inside your components in three places where it was previously unavailable:

- at the top level of your component's `<script>`
- inside `$derived(...)` declarations
- inside your markup

This feature is currently experimental, and you must opt in by adding the `experimental.async` option wherever you [configure](/docs/kit/configuration) Svelte, usually `svelte.config.js`:

```js
/// file: svelte.config.js
export default {
	compilerOptions: {
		experimental: {
			async: true
		}
	}
};
```

The experimental flag will be removed in Svelte 6.

## Synchronized updates

When an `await` expression depends on a particular piece of state, changes to that state will not be reflected in the UI until the asynchronous work has completed, so that the UI is not left in an inconsistent state

```svelte
<script>
	let a = $state(1);
	let b = $state(2);

	async function add(a, b) {
		await new Promise((f) => setTimeout(f, 500)); // artificial delay
		return a + b;
	}
</script>

<input type="number" bind:value={a} />
<input type="number" bind:value={b} />

<p>{a} + {b} = {await add(a, b)}</p>
```

...if you increment `a`, the contents of the `<p>` will _not_ immediately update to read this —

```html
<p>2 + 2 = 3</p>
```

— instead, the text will update to `2 + 2 = 4` when `add(a, b)` resolves.

Updates can overlap — a fast update will be reflected in the UI while an earlier slow update is still ongoing.

## Concurrency

Svelte will do as much asynchronous work as it can in parallel. For example if you have two `await` expressions in your markup...

```svelte
<p>{await one()}</p><p>{await two()}</p>
```

...both functions will run at the same time, as they are independent expressions, even though they are _visually_ sequential.

This does not apply to sequential `await` expressions inside your `<script>` or inside async functions — these run like any other asynchronous JavaScript. An exception is that independent `$derived` expressions will update independently, even though they will run sequentially when they are first created:

```js
async function one() {
	return 1;
}
async function two() {
	return 2;
}
// ---cut---
// these will run sequentially the first time,
// but will update independently
let a = $derived(await one());
let b = $derived(await two());
```

> [!NOTE] If you write code like this, expect Svelte to give you an [`await_waterfall`](runtime-warnings#Client-warnings-await_waterfall) warning

## Indicating loading states

To render placeholder UI, you can wrap content in a `<svelte:boundary>` with a [`pending`](svelte-boundary#Properties-pending) snippet. This will be shown when the boundary is first created, but not for subsequent updates, which are globally coordinated.

After the contents of a boundary have resolved for the first time and have replaced the `pending` snippet, you can detect subsequent async work with [`$effect.pending()`]($effect#$effect.pending). This is what you would use to display a "we're asynchronously validating your input" spinner next to a form field, for example.

You can also use [`settled()`](svelte#settled) to get a promise that resolves when the current update is complete:

```js
let color = 'red';
let answer = -1;
let updating = false;
// ---cut---
import { tick, settled } from 'svelte';

async function onclick() {
	updating = true;

	// without this, the change to `updating` will be
	// grouped with the other changes, meaning it
	// won't be reflected in the UI
	await tick();

	color = 'octarine';
	answer = 42;

	await settled();

	// any updates affected by `color` or `answer`
	// have now been applied
	updating = false;
}
```

## Error handling

Errors in `await` expressions will bubble to the nearest [error boundary](svelte-boundary).

## Server-side rendering

Svelte supports asynchronous server-side rendering (SSR) with the `render(...)` API. To use it, simply await the return value:

```js
/// file: server.js
import { render } from 'svelte/server';
import App from './App.svelte';

const { head, body } = +++await+++ render(App);
```

> [!NOTE] If you're using a framework like SvelteKit, this is done on your behalf.

If a `<svelte:boundary>` with a `pending` snippet is encountered during SSR, that snippet will be rendered while the rest of the content is ignored. All `await` expressions encountered outside boundaries with `pending` snippets will resolve and render their contents prior to `await render(...)` returning.

> [!NOTE] In the future, we plan to add a streaming implementation that renders the content in the background.

## Caveats

As an experimental feature, the details of how `await` is handled (and related APIs like `$effect.pending()`) are subject to breaking changes outside of a semver major release, though we intend to keep such changes to a bare minimum.

## Breaking changes

Effects run in a slightly different order when the `experimental.async` option is `true`. Specifically, _block_ effects like `{#if ...}` and `{#each ...}` now run before an `$effect.pre` or `beforeUpdate` in the same component, which means that in very rare situations it is possible to update a block that should no longer exist, but only if you update state inside an effect, which you should avoid
